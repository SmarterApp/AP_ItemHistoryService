package org.opentestsystem.ap.item.history;

import lombok.extern.slf4j.Slf4j;
import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.math.NumberUtils;
import org.opentestsystem.ap.common.assembler.AppAssembler;
import org.opentestsystem.ap.common.config.ItemBankProperties;
import org.opentestsystem.ap.common.datastore.DataStoreAttachmentManager;
import org.opentestsystem.ap.common.datastore.DataStoreDataManager;
import org.opentestsystem.ap.common.datastore.DataStoreUtility;
import org.opentestsystem.ap.common.datastore.entity.ItemEntity;
import org.opentestsystem.ap.common.datastore.entity.ItemHistoryEntity;
import org.opentestsystem.ap.common.exception.SystemException;
import org.opentestsystem.ap.common.management.ItemEventHandler;
import org.opentestsystem.ap.common.management.events.ItemEvent;
import org.opentestsystem.ap.common.model.Item;
import org.opentestsystem.ap.common.saaif.ItemContext;
import org.opentestsystem.ap.common.saaif.transformer.ModelTransformer;
import org.opentestsystem.ap.common.saaif.transformer.TransformerFactory;
import org.opentestsystem.ap.common.security.model.ItemBankUser;
import org.opentestsystem.ap.common.util.ImageGenerator;
import org.opentestsystem.ap.common.util.RandomIdGenerator;
import org.opentestsystem.ap.common.util.StopWatchLogger;

import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.UUID;

/**
 * Processes item authoring events, recording the appropriate history data associated with it.
 */
@Slf4j
public class ItemHistoryEventHandler implements ItemEventHandler {

    private final RandomIdGenerator idGenerator = new RandomIdGenerator(NumberUtils.INTEGER_ZERO, Integer.MAX_VALUE);

    private final ItemBankProperties itemBankProperties;

    private final DataStoreDataManager dataStoreDataManager;

    private final DataStoreAttachmentManager dataStoreAttachmentManager;

    private final DataStoreUtility dataStoreUtility;

    private final TransformerFactory transformerFactory;

    private final ImageGenerator imageGenerator;

    private final AppAssembler appAssembler;

    public ItemHistoryEventHandler(ItemBankProperties itemBankProperties,
                                   DataStoreDataManager dataStoreDataManager,
                                   DataStoreAttachmentManager dataStoreAttachmentManager,
                                   DataStoreUtility dataStoreUtility,
                                   TransformerFactory transformerFactory,
                                   ImageGenerator imageGenerator,
                                   AppAssembler appAssembler) {
        this.itemBankProperties = itemBankProperties;
        this.dataStoreDataManager = dataStoreDataManager;
        this.dataStoreAttachmentManager = dataStoreAttachmentManager;
        this.dataStoreUtility = dataStoreUtility;
        this.transformerFactory = transformerFactory;
        this.imageGenerator = imageGenerator;
        this.appAssembler = appAssembler;
    }

    /**
     * Handles all item events.
     *
     * @param itemEvent the {@link ItemEvent} with the item change
     */
    public void onItemEvent(ItemEvent itemEvent) {
        StopWatchLogger watch = StopWatchLogger.start();
        String eventType = itemEvent.getType();
        switch (eventType) {
            case ItemEvent.TYPE_COMMIT:
            case ItemEvent.TYPE_PATCH:
                ItemEntity masterCommit = this.dataStoreDataManager.findById(itemEvent.getMasterCommitId());
                if (!masterCommit.isBeingEdited()) {
                    log.info("[HISTORY] {} - item {} | master commit {} | branch commit {} | username {}",
                        StringUtils.upperCase(eventType),
                        masterCommit.getItemId(),
                        itemEvent.getMasterCommitId(),
                        itemEvent.getBranchCommitId(),
                        itemEvent.getUser().getUserName());
                    // commit and patch are the same
                    this.saveHistoryRecord(itemEvent, masterCommit);
                } else {
                    log.info("[HISTORY] SKIP {} - item {} is being edited | master commit {} username {}",
                        StringUtils.upperCase(eventType),
                        masterCommit.getItemId(),
                        itemEvent.getMasterCommitId(),
                        itemEvent.getUser().getUserName());
                }
                break;
            case ItemEvent.TYPE_CREATE:
            case ItemEvent.TYPE_DELETE:
                log.debug("[HISTORY] {} [ignore] - item {}", eventType.toUpperCase(), itemEvent.getItemId());
                break;
            default:
                log.warn("[HISTORY] Unknown item event type " + eventType + ", item " + itemEvent.getItemId());
                break;
        }
        watch.stop(log, "[HISTORY] " + StringUtils.upperCase(eventType));
    }

    // ------------------------------------------------------------------------

    /**
     * This is the main method for saving the history record for a commit or patch event.  The item's attachments are
     * downloaded and the SAAIF is generated.  The generated SAAIF files and attachments are zipped and saved to S3.  S3
     * gives us a version ID which we use to save on the item history record.
     *
     * @param event      The event data.
     * @param itemEntity The item record to save a history record for.
     */
    private void saveHistoryRecord(ItemEvent event, ItemEntity itemEntity) {
        ItemBankUser user = event.getUser();

        Item item = this.dataStoreUtility.cloneItemJson(itemEntity.getItemJson());

        Path itemFolder = this.downloadAttachments(item.getId(), item.getServerManaged().getTimsAttachmentsVersionId());

        this.generateSaaifContent(item, itemFolder);

        // lock item
        // get oldest history record
        // use commit id to get content (downloadSaaifContent)
        // generate diff content
        // add diff content to ItemHistoryEntity
        // save ItemHistoryEntity

        String saaifContentVersionId = this.dataStoreAttachmentManager.commitSaaifContent(
            item.getId(), itemFolder);

        // create history record
        this.dataStoreDataManager.saveItemHistory(
            new ItemHistoryEntity(
                item.getId(),
                UUID.fromString(event.getMasterCommitId()),
                UUID.fromString(event.getBranchCommitId()),
                saaifContentVersionId,
                user.getUserName(),
                user.getFullName(),
                itemEntity.getCreatedDate(),
                event.getComment()
            )
        );
    }

    /**
     * The item is used to generated SAAIF files in the given item folder.
     *
     * @param item       The item to generate SAAIF for.
     * @param itemFolder The folder to generate the data in.
     */
    private void generateSaaifContent(Item item, Path itemFolder) {
        ItemContext itemContext = new ItemContext(
            item.getId(),
            item.getLegacyId(this.itemBankProperties.getBankKey()),
            this.itemBankProperties.getBankKey(),
            this.appAssembler,
            itemFolder
        );
        ModelTransformer transformer = transformerFactory.newTransformer(item.getType(), this.imageGenerator);
        transformer.generateSaaifFiles(item, itemBankProperties.getBankKey(), itemContext);
    }

    /**
     * Downloads the attachments associated with the item.  The attachments version is used if provided.  It is used to
     * download a specific version of the attachment.  If the version is not provided the latest version of the
     * attachments are downloaded individually.  This is a fallback behavior as it is expected the version ID is
     * provided as it should have been generate prior to the item event being sent.
     *
     * @param itemId              The item to download the attachments for.
     * @param attachmentVersionId The version of the attachments to download.
     * @return The path were the attachments have been downloaded.
     */
    private Path downloadAttachments(String itemId, String attachmentVersionId) {
        if (StringUtils.isBlank(attachmentVersionId)) {
            throw new SystemException("[TIMS-HISTORY-ERROR] Item " + itemId + " is missing attachment version ID.");
        }
        // use 'localBaseDir' so the clean up process takes care of deleting these files
        Path downloadFolder = Paths.get(itemBankProperties.getLocalBaseDir(), idGenerator.generateTransactionId());
        dataStoreAttachmentManager.downloadVersionedAttachments(itemId, attachmentVersionId, downloadFolder);
        return downloadFolder;
    }
}
